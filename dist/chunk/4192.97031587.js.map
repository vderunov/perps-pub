{"version":3,"file":"chunk/4192.97031587.js","mappings":"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","sources":["webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/_assert.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/utils.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/address.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/base.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/utils.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/data.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/errors/encoding.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/lru.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/address/getAddress.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/address/isAddress.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/concat.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/isHex.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/pad.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/size.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/data/slice.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/encoding/fromHex.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/encoding/toBytes.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/encoding/toHex.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/_u64.js","webpack://@snx-v3/liquidity/../../node_modules/@noble/hashes/esm/sha3.js","webpack://@snx-v3/liquidity/../../node_modules/viem/_esm/utils/hash/keccak256.js"],"sourcesContent":["function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { BaseError } from './base.js';\nexport class InvalidAddressError extends BaseError {\n    constructor({ address }) {\n        super(`Address \"${address}\" is invalid.`, {\n            metaMessages: [\n                '- Address must be a hex value of 20 bytes (40 hex characters).',\n                '- Address must match its checksum counterpart.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidAddressError'\n        });\n    }\n}\n//# sourceMappingURL=address.js.map","import { getVersion } from './utils.js';\nexport class BaseError extends Error {\n    constructor(shortMessage, args = {}) {\n        super();\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"metaMessages\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'ViemError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getVersion()\n        });\n        const details = args.cause instanceof BaseError\n            ? args.cause.details\n            : args.cause?.message\n                ? args.cause.message\n                : args.details;\n        const docsPath = args.cause instanceof BaseError\n            ? args.cause.docsPath || args.docsPath\n            : args.docsPath;\n        this.message = [\n            shortMessage || 'An error occurred.',\n            '',\n            ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n            ...(docsPath\n                ? [\n                    `Docs: ${args.docsBaseUrl ?? 'https://viem.sh'}${docsPath}${args.docsSlug ? `#${args.docsSlug}` : ''}`,\n                ]\n                : []),\n            ...(details ? [`Details: ${details}`] : []),\n            `Version: ${this.version}`,\n        ].join('\\n');\n        if (args.cause)\n            this.cause = args.cause;\n        this.details = details;\n        this.docsPath = docsPath;\n        this.metaMessages = args.metaMessages;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=base.js.map","import { version } from './version.js';\nexport const getContractAddress = (address) => address;\nexport const getUrl = (url) => url;\nexport const getVersion = () => `viem@${version}`;\n//# sourceMappingURL=utils.js.map","import { BaseError } from './base.js';\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \"${offset}\" is out-of-bounds (size: ${size}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nexport class SizeExceedsPaddingSizeError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeExceedsPaddingSizeError'\n        });\n    }\n}\nexport class InvalidBytesLengthError extends BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesLengthError'\n        });\n    }\n}\n//# sourceMappingURL=data.js.map","import { BaseError } from './base.js';\nexport class IntegerOutOfRangeError extends BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \"${value}\" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'IntegerOutOfRangeError'\n        });\n    }\n}\nexport class InvalidBytesBooleanError extends BaseError {\n    constructor(bytes) {\n        super(`Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidBytesBooleanError'\n        });\n    }\n}\nexport class InvalidHexBooleanError extends BaseError {\n    constructor(hex) {\n        super(`Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexBooleanError'\n        });\n    }\n}\nexport class InvalidHexValueError extends BaseError {\n    constructor(value) {\n        super(`Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'InvalidHexValueError'\n        });\n    }\n}\nexport class SizeOverflowError extends BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SizeOverflowError'\n        });\n    }\n}\n//# sourceMappingURL=encoding.js.map","/**\n * Map with a LRU (Least recently used) policy.\n *\n * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize)\n            this.delete(this.keys().next().value);\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map","import { InvalidAddressError } from '../../errors/address.js';\nimport { stringToBytes, } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { LruMap } from '../lru.js';\nimport { isAddress } from './isAddress.js';\nconst checksumAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function checksumAddress(address_, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (checksumAddressCache.has(`${address_}.${chainId}`))\n        return checksumAddressCache.get(`${address_}.${chainId}`);\n    const hexAddress = chainId\n        ? `${chainId}${address_.toLowerCase()}`\n        : address_.substring(2).toLowerCase();\n    const hash = keccak256(stringToBytes(hexAddress), 'bytes');\n    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n            address[i] = address[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n            address[i + 1] = address[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${address.join('')}`;\n    checksumAddressCache.set(`${address_}.${chainId}`, result);\n    return result;\n}\nexport function getAddress(address, \n/**\n * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the\n * wider Ethereum ecosystem, meaning it will break when validated against an application/tool\n * that relies on EIP-55 checksum encoding (checksum without chainId).\n *\n * It is highly recommended to not use this feature unless you\n * know what you are doing.\n *\n * See more: https://github.com/ethereum/EIPs/issues/1121\n */\nchainId) {\n    if (!isAddress(address, { strict: false }))\n        throw new InvalidAddressError({ address });\n    return checksumAddress(address, chainId);\n}\n//# sourceMappingURL=getAddress.js.map","import { LruMap } from '../lru.js';\nimport { checksumAddress } from './getAddress.js';\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/** @internal */\nexport const isAddressCache = /*#__PURE__*/ new LruMap(8192);\nexport function isAddress(address, options) {\n    const { strict = true } = options ?? {};\n    const cacheKey = `${address}.${strict}`;\n    if (isAddressCache.has(cacheKey))\n        return isAddressCache.get(cacheKey);\n    const result = (() => {\n        if (!addressRegex.test(address))\n            return false;\n        if (address.toLowerCase() === address)\n            return true;\n        if (strict)\n            return checksumAddress(address) === address;\n        return true;\n    })();\n    isAddressCache.set(cacheKey, result);\n    return result;\n}\n//# sourceMappingURL=isAddress.js.map","export function concat(values) {\n    if (typeof values[0] === 'string')\n        return concatHex(values);\n    return concatBytes(values);\n}\nexport function concatBytes(values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    let offset = 0;\n    for (const arr of values) {\n        result.set(arr, offset);\n        offset += arr.length;\n    }\n    return result;\n}\nexport function concatHex(values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n//# sourceMappingURL=concat.js.map","export function isHex(value, { strict = true } = {}) {\n    if (!value)\n        return false;\n    if (typeof value !== 'string')\n        return false;\n    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');\n}\n//# sourceMappingURL=isHex.js.map","import { SizeExceedsPaddingSizeError, } from '../../errors/data.js';\nexport function pad(hexOrBytes, { dir, size = 32 } = {}) {\n    if (typeof hexOrBytes === 'string')\n        return padHex(hexOrBytes, { dir, size });\n    return padBytes(hexOrBytes, { dir, size });\n}\nexport function padHex(hex_, { dir, size = 32 } = {}) {\n    if (size === null)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\nexport function padBytes(bytes, { dir, size = 32 } = {}) {\n    if (size === null)\n        return bytes;\n    if (bytes.length > size)\n        throw new SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n//# sourceMappingURL=pad.js.map","import { isHex } from './isHex.js';\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value) {\n    if (isHex(value, { strict: false }))\n        return Math.ceil((value.length - 2) / 2);\n    return value.length;\n}\n//# sourceMappingURL=size.js.map","import { SliceOffsetOutOfBoundsError, } from '../../errors/data.js';\nimport { isHex } from './isHex.js';\nimport { size } from './size.js';\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice(value, start, end, { strict } = {}) {\n    if (isHex(value, { strict: false }))\n        return sliceHex(value, start, end, {\n            strict,\n        });\n    return sliceBytes(value, start, end, {\n        strict,\n    });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n        throw new SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        size(value) !== end - start) {\n        throw new SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: size(value),\n        });\n    }\n}\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = value_.slice(start, end);\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(value_, start, end, { strict } = {}) {\n    assertStartOffset(value_, start);\n    const value = `0x${value_\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\n    if (strict)\n        assertEndOffset(value, start, end);\n    return value;\n}\n//# sourceMappingURL=slice.js.map","import { InvalidHexBooleanError, SizeOverflowError, } from '../../errors/encoding.js';\nimport { size as size_ } from '../data/size.js';\nimport { trim } from '../data/trim.js';\nimport { hexToBytes } from './toBytes.js';\nexport function assertSize(hexOrBytes, { size }) {\n    if (size_(hexOrBytes) > size)\n        throw new SizeOverflowError({\n            givenSize: size_(hexOrBytes),\n            maxSize: size,\n        });\n}\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex\n * - Example: https://viem.sh/docs/utilities/fromHex#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex(hex, toOrOpts) {\n    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;\n    const to = opts.to;\n    if (to === 'number')\n        return hexToNumber(hex, opts);\n    if (to === 'bigint')\n        return hexToBigInt(hex, opts);\n    if (to === 'string')\n        return hexToString(hex, opts);\n    if (to === 'boolean')\n        return hexToBool(hex, opts);\n    return hexToBytes(hex, opts);\n}\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex, opts = {}) {\n    const { signed } = opts;\n    if (opts.size)\n        assertSize(hex, { size: opts.size });\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n    if (value <= max)\n        return value;\n    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = trim(hex);\n    }\n    if (trim(hex) === '0x00')\n        return false;\n    if (trim(hex) === '0x01')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex, opts = {}) {\n    return Number(hexToBigInt(hex, opts));\n}\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex, opts = {}) {\n    let bytes = hexToBytes(hex);\n    if (opts.size) {\n        assertSize(bytes, { size: opts.size });\n        bytes = trim(bytes, { dir: 'right' });\n    }\n    return new TextDecoder().decode(bytes);\n}\n//# sourceMappingURL=fromHex.js.map","import { BaseError } from '../../errors/base.js';\nimport { isHex } from '../data/isHex.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nimport { numberToHex, } from './toHex.js';\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes\n * - Example: https://viem.sh/docs/utilities/toBytes#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToBytes(value, opts);\n    if (typeof value === 'boolean')\n        return boolToBytes(value, opts);\n    if (isHex(value))\n        return hexToBytes(value, opts);\n    return stringToBytes(value, opts);\n}\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value, opts = {}) {\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { size: opts.size });\n    }\n    return bytes;\n}\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_, opts = {}) {\n    let hex = hex_;\n    if (opts.size) {\n        assertSize(hex, { size: opts.size });\n        hex = pad(hex, { dir: 'right', size: opts.size });\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value, opts) {\n    const hex = numberToHex(value, opts);\n    return hexToBytes(hex);\n}\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(value, opts = {}) {\n    const bytes = encoder.encode(value);\n    if (typeof opts.size === 'number') {\n        assertSize(bytes, { size: opts.size });\n        return pad(bytes, { dir: 'right', size: opts.size });\n    }\n    return bytes;\n}\n//# sourceMappingURL=toBytes.js.map","import { IntegerOutOfRangeError, } from '../../errors/encoding.js';\nimport { pad } from '../data/pad.js';\nimport { assertSize } from './fromHex.js';\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex\n * - Example: https://viem.sh/docs/utilities/toHex#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(value, opts = {}) {\n    if (typeof value === 'number' || typeof value === 'bigint')\n        return numberToHex(value, opts);\n    if (typeof value === 'string') {\n        return stringToHex(value, opts);\n    }\n    if (typeof value === 'boolean')\n        return boolToHex(value, opts);\n    return bytesToHex(value, opts);\n}\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value, opts = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value, opts = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++) {\n        string += hexes[value[i]];\n    }\n    const hex = `0x${string}`;\n    if (typeof opts.size === 'number') {\n        assertSize(hex, { size: opts.size });\n        return pad(hex, { dir: 'right', size: opts.size });\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(value_, opts = {}) {\n    const { signed, size } = opts;\n    const value = BigInt(value_);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value_ === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value > maxValue) || value < minValue) {\n        const suffix = typeof value_ === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value_}${suffix}`,\n        });\n    }\n    const hex = `0x${(signed && value < 0\n        ? (1n << BigInt(size * 8)) + BigInt(value)\n        : value).toString(16)}`;\n    if (size)\n        return pad(hex, { size });\n    return hex;\n}\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_, opts = {}) {\n    const value = encoder.encode(value_);\n    return bytesToHex(value, opts);\n}\n//# sourceMappingURL=toHex.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","import { keccak_256 } from '@noble/hashes/sha3';\nimport { isHex } from '../data/isHex.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { toHex } from '../encoding/toHex.js';\nexport function keccak256(value, to_) {\n    const to = to_ || 'hex';\n    const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);\n    if (to === 'bytes')\n        return bytes;\n    return toHex(bytes);\n}\n//# sourceMappingURL=keccak256.js.map"],"names":["number","n","Number","isSafeInteger","Error","bytes","b","lengths","a","Uint8Array","constructor","name","length","includes","exists","instance","checkFinished","destroyed","finished","output","out","min","outputLen","u32","arr","Uint32Array","buffer","byteOffset","Math","floor","byteLength","createView","DataView","rotr","word","shift","isLE","byteSwap","byteSwap32","i","toBytes","data","str","TextEncoder","encode","utf8ToBytes","Hash","clone","this","_cloneInto","wrapConstructor","hashCons","hashC","msg","update","digest","tmp","blockLen","create","InvalidAddressError","address","super","metaMessages","Object","defineProperty","enumerable","configurable","writable","value","BaseError","shortMessage","args","details","cause","message","docsPath","docsBaseUrl","docsSlug","version","join","walk","fn","err","SliceOffsetOutOfBoundsError","offset","position","size","SizeExceedsPaddingSizeError","targetSize","type","charAt","toUpperCase","slice","toLowerCase","IntegerOutOfRangeError","max","signed","SizeOverflowError","givenSize","maxSize","LruMap","Map","set","key","delete","keys","next","checksumAddressCache","checksumAddress","address_","chainId","has","get","hexAddress","substring","hash","keccak256","split","result","addressRegex","isAddressCache","options","strict","cacheKey","test","concat","values","concatHex","concatBytes","reduce","acc","x","replace","isHex","startsWith","pad","hexOrBytes","dir","padHex","paddedBytes","padEnd","padBytes","hex_","hex","ceil","start","end","value_","assertStartOffset","assertEndOffset","sliceHex","sliceBytes","assertSize","hexToBigInt","opts","BigInt","padStart","hexToNumber","encoder","hexToBytes","numberToBytes","boolToBytes","stringToBytes","charCodeMap","zero","nine","A","F","f","charCodeToBase16","char","hexString","index","j","nibbleLeft","charCodeAt","nibbleRight","undefined","hexes","Array","from","_v","toString","toHex","numberToHex","stringToHex","boolToHex","bytesToHex","string","maxValue","MAX_SAFE_INTEGER","minValue","suffix","U32_MASK64","_32n","fromBig","le","h","l","lst","Ah","Al","rotlSH","s","rotlSL","rotlBH","rotlBL","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","y","push","t","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","Keccak","enableXOF","rounds","pos","posOut","state","state32","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","fill","keccakP","len","take","finish","writeInto","bufferOut","subarray","xofInto","xof","digestInto","destroy","to","gen","keccak_256","to_"],"sourceRoot":""}