{"version":3,"file":"chunk/4574.405c2770.js","mappings":"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","sources":["webpack://@snx-v3/liquidity/../../node_modules/base-x/src/index.js","webpack://@snx-v3/liquidity/../../node_modules/bs58/index.js","webpack://@snx-v3/liquidity/../../node_modules/bs58check/base.js","webpack://@snx-v3/liquidity/../../node_modules/bs58check/index.js","webpack://@snx-v3/liquidity/../../node_modules/hdkey/lib/hdkey.js","webpack://@snx-v3/liquidity/../../node_modules/hdkey/node_modules/secp256k1/elliptic.js","webpack://@snx-v3/liquidity/../../node_modules/hdkey/node_modules/secp256k1/lib/elliptic.js","webpack://@snx-v3/liquidity/../../node_modules/hdkey/node_modules/secp256k1/lib/index.js"],"sourcesContent":["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","var assert = require('assert')\nvar Buffer = require('safe-buffer').Buffer\nvar crypto = require('crypto')\nvar bs58check = require('bs58check')\nvar RIPEMD160 = require('ripemd160')\nvar secp256k1 = require('secp256k1')\n\nvar MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')\nvar HARDENED_OFFSET = 0x80000000\nvar LEN = 78\n\n// Bitcoin hardcoded by default, can use package `coininfo` for others\nvar BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}\n\nfunction HDKey (versions) {\n  this.versions = versions || BITCOIN_VERSIONS\n  this.depth = 0\n  this.index = 0\n  this._privateKey = null\n  this._publicKey = null\n  this.chainCode = null\n  this._fingerprint = 0\n  this.parentFingerprint = 0\n}\n\nObject.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })\nObject.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })\nObject.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })\n\nObject.defineProperty(HDKey.prototype, 'privateKey', {\n  get: function () {\n    return this._privateKey\n  },\n  set: function (value) {\n    assert.equal(value.length, 32, 'Private key must be 32 bytes.')\n    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')\n\n    this._privateKey = value\n    this._publicKey = Buffer.from(secp256k1.publicKeyCreate(value, true))\n    this._identifier = hash160(this.publicKey)\n    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)\n  }\n})\n\nfunction setPublicKey (hdkey, publicKey) {\n  hdkey._publicKey = Buffer.from(publicKey)\n  hdkey._identifier = hash160(publicKey)\n  hdkey._fingerprint = hdkey._identifier.slice(0, 4).readUInt32BE(0)\n  hdkey._privateKey = null\n}\n\nObject.defineProperty(HDKey.prototype, 'publicKey', {\n  get: function () {\n    return this._publicKey\n  },\n  set: function (value) {\n    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')\n    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')\n    // force compressed point (performs public key verification)\n    const publicKey = (value.length === 65) ? secp256k1.publicKeyConvert(value, true) : value\n    setPublicKey(this, publicKey)\n  }\n})\n\nObject.defineProperty(HDKey.prototype, 'privateExtendedKey', {\n  get: function () {\n    if (this._privateKey) return bs58check.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))\n    else return null\n  }\n})\n\nObject.defineProperty(HDKey.prototype, 'publicExtendedKey', {\n  get: function () {\n    return bs58check.encode(serialize(this, this.versions.public, this.publicKey))\n  }\n})\n\nHDKey.prototype.derive = function (path) {\n  if (path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n    return this\n  }\n\n  var entries = path.split('/')\n  var hdkey = this\n  entries.forEach(function (c, i) {\n    if (i === 0) {\n      assert(/^[mM]{1}/.test(c), 'Path must start with \"m\" or \"M\"')\n      return\n    }\n\n    var hardened = (c.length > 1) && (c[c.length - 1] === \"'\")\n    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)\n    assert(childIndex < HARDENED_OFFSET, 'Invalid index')\n    if (hardened) childIndex += HARDENED_OFFSET\n\n    hdkey = hdkey.deriveChild(childIndex)\n  })\n\n  return hdkey\n}\n\nHDKey.prototype.deriveChild = function (index) {\n  var isHardened = index >= HARDENED_OFFSET\n  var indexBuffer = Buffer.allocUnsafe(4)\n  indexBuffer.writeUInt32BE(index, 0)\n\n  var data\n\n  if (isHardened) { // Hardened child\n    assert(this.privateKey, 'Could not derive hardened child key')\n\n    var pk = this.privateKey\n    var zb = Buffer.alloc(1, 0)\n    pk = Buffer.concat([zb, pk])\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data = Buffer.concat([pk, indexBuffer])\n  } else { // Normal child\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    data = Buffer.concat([this.publicKey, indexBuffer])\n  }\n\n  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var hd = new HDKey(this.versions)\n\n  // Private parent key -> private child key\n  if (this.privateKey) {\n    // ki = parse256(IL) + kpar (mod n)\n    try {\n      hd.privateKey = Buffer.from(secp256k1.privateKeyTweakAdd(Buffer.from(this.privateKey), IL))\n      // throw if IL >= n || (privateKey + IL) === 0\n    } catch (err) {\n      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i\n      return this.deriveChild(index + 1)\n    }\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    try {\n      hd.publicKey = Buffer.from(secp256k1.publicKeyTweakAdd(Buffer.from(this.publicKey), IL, true))\n      // throw if IL >= n || (g**IL + publicKey) is infinity\n    } catch (err) {\n      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i\n      return this.deriveChild(index + 1)\n    }\n  }\n\n  hd.chainCode = IR\n  hd.depth = this.depth + 1\n  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)\n  hd.index = index\n\n  return hd\n}\n\nHDKey.prototype.sign = function (hash) {\n  return Buffer.from(secp256k1.ecdsaSign(Uint8Array.from(hash), Uint8Array.from(this.privateKey)).signature)\n}\n\nHDKey.prototype.verify = function (hash, signature) {\n  return secp256k1.ecdsaVerify(\n    Uint8Array.from(signature),\n    Uint8Array.from(hash),\n    Uint8Array.from(this.publicKey)\n  )\n}\n\nHDKey.prototype.wipePrivateData = function () {\n  if (this._privateKey) crypto.randomBytes(this._privateKey.length).copy(this._privateKey)\n  this._privateKey = null\n  return this\n}\n\nHDKey.prototype.toJSON = function () {\n  return {\n    xpriv: this.privateExtendedKey,\n    xpub: this.publicExtendedKey\n  }\n}\n\nHDKey.fromMasterSeed = function (seedBuffer, versions) {\n  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()\n  var IL = I.slice(0, 32)\n  var IR = I.slice(32)\n\n  var hdkey = new HDKey(versions)\n  hdkey.chainCode = IR\n  hdkey.privateKey = IL\n\n  return hdkey\n}\n\nHDKey.fromExtendedKey = function (base58key, versions, skipVerification) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  versions = versions || BITCOIN_VERSIONS\n  skipVerification = skipVerification || false\n  var hdkey = new HDKey(versions)\n\n  var keyBuffer = bs58check.decode(base58key)\n\n  var version = keyBuffer.readUInt32BE(0)\n  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')\n\n  hdkey.depth = keyBuffer.readUInt8(4)\n  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)\n  hdkey.index = keyBuffer.readUInt32BE(9)\n  hdkey.chainCode = keyBuffer.slice(13, 45)\n\n  var key = keyBuffer.slice(45)\n  if (key.readUInt8(0) === 0) { // private\n    assert(version === versions.private, 'Version mismatch: version does not match private')\n    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte\n  } else {\n    assert(version === versions.public, 'Version mismatch: version does not match public')\n    if (skipVerification) {\n      setPublicKey(hdkey, key)\n    } else {\n      hdkey.publicKey = key\n    }\n  }\n\n  return hdkey\n}\n\nHDKey.fromJSON = function (obj) {\n  return HDKey.fromExtendedKey(obj.xpriv)\n}\n\nfunction serialize (hdkey, version, key) {\n  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n  var buffer = Buffer.allocUnsafe(LEN)\n\n  buffer.writeUInt32BE(version, 0)\n  buffer.writeUInt8(hdkey.depth, 4)\n\n  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000\n  buffer.writeUInt32BE(fingerprint, 5)\n  buffer.writeUInt32BE(hdkey.index, 9)\n\n  hdkey.chainCode.copy(buffer, 13)\n  key.copy(buffer, 45)\n\n  return buffer\n}\n\nfunction hash160 (buf) {\n  var sha = crypto.createHash('sha256').update(buf).digest()\n  return new RIPEMD160().update(sha).digest()\n}\n\nHDKey.HARDENED_OFFSET = HARDENED_OFFSET\nmodule.exports = HDKey\n","module.exports = require('./lib')(require('./lib/elliptic'))\n","const EC = require('elliptic').ec\n\nconst ec = new EC('secp256k1')\nconst ecparams = ec.curve\n\n// Hack, we can not use bn.js@5, while elliptic uses bn.js@4\n// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758\nconst BN = ecparams.n.constructor\n\nfunction loadCompressedPublicKey (first, xbuf) {\n  let x = new BN(xbuf)\n\n  // overflow\n  if (x.cmp(ecparams.p) >= 0) return null\n  x = x.toRed(ecparams.red)\n\n  // compute corresponding Y\n  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()\n  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()\n\n  return ec.keyPair({ pub: { x: x, y: y } })\n}\n\nfunction loadUncompressedPublicKey (first, xbuf, ybuf) {\n  let x = new BN(xbuf)\n  let y = new BN(ybuf)\n\n  // overflow\n  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null\n\n  x = x.toRed(ecparams.red)\n  y = y.toRed(ecparams.red)\n\n  // is odd flag\n  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null\n\n  // x*x*x + b = y*y\n  const x3 = x.redSqr().redIMul(x)\n  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null\n\n  return ec.keyPair({ pub: { x: x, y: y } })\n}\n\nfunction loadPublicKey (pubkey) {\n  // length should be validated in interface\n  const first = pubkey[0]\n  switch (first) {\n    case 0x02:\n    case 0x03:\n      if (pubkey.length !== 33) return null\n      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))\n    case 0x04:\n    case 0x06:\n    case 0x07:\n      if (pubkey.length !== 65) return null\n      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))\n    default:\n      return null\n  }\n}\n\nfunction savePublicKey (output, point) {\n  const pubkey = point.encode(null, output.length === 33)\n  // Loop should be faster because we do not need create extra Uint8Array\n  // output.set(new Uint8Array(pubkey))\n  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]\n}\n\nmodule.exports = {\n  contextRandomize () {\n    return 0\n  },\n\n  privateKeyVerify (seckey) {\n    const bn = new BN(seckey)\n    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1\n  },\n\n  privateKeyNegate (seckey) {\n    const bn = new BN(seckey)\n    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(negate)\n    return 0\n  },\n\n  privateKeyTweakAdd (seckey, tweak) {\n    const bn = new BN(tweak)\n    if (bn.cmp(ecparams.n) >= 0) return 1\n\n    bn.iadd(new BN(seckey))\n    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)\n    if (bn.isZero()) return 1\n\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(tweaked)\n\n    return 0\n  },\n\n  privateKeyTweakMul (seckey, tweak) {\n    let bn = new BN(tweak)\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1\n\n    bn.imul(new BN(seckey))\n    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)\n\n    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)\n    seckey.set(tweaked)\n\n    return 0\n  },\n\n  publicKeyVerify (pubkey) {\n    const pair = loadPublicKey(pubkey)\n    return pair === null ? 1 : 0\n  },\n\n  publicKeyCreate (output, seckey) {\n    const bn = new BN(seckey)\n    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1\n\n    const point = ec.keyFromPrivate(seckey).getPublic()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyConvert (output, pubkey) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const point = pair.getPublic()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyNegate (output, pubkey) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const point = pair.getPublic()\n    point.y = point.y.redNeg()\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyCombine (output, pubkeys) {\n    const pairs = new Array(pubkeys.length)\n    for (let i = 0; i < pubkeys.length; ++i) {\n      pairs[i] = loadPublicKey(pubkeys[i])\n      if (pairs[i] === null) return 1\n    }\n\n    let point = pairs[0].getPublic()\n    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)\n    if (point.isInfinity()) return 2\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyTweakAdd (output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    tweak = new BN(tweak)\n    if (tweak.cmp(ecparams.n) >= 0) return 2\n\n    const point = pair.getPublic().add(ecparams.g.mul(tweak))\n    if (point.isInfinity()) return 2\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  publicKeyTweakMul (output, pubkey, tweak) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    tweak = new BN(tweak)\n    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2\n\n    const point = pair.getPublic().mul(tweak)\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  signatureNormalize (sig) {\n    const r = new BN(sig.subarray(0, 32))\n    const s = new BN(sig.subarray(32, 64))\n    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1\n\n    if (s.cmp(ec.nh) === 1) {\n      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)\n    }\n\n    return 0\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureExport (obj, sig) {\n    const sigR = sig.subarray(0, 32)\n    const sigS = sig.subarray(32, 64)\n    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1\n    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1\n\n    const { output } = obj\n\n    // Prepare R\n    let r = output.subarray(4, 4 + 33)\n    r[0] = 0x00\n    r.set(sigR, 1)\n\n    let lenR = 33\n    let posR = 0\n    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);\n\n    r = r.subarray(posR)\n    if (r[0] & 0x80) return 1\n    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1\n\n    // Prepare S\n    let s = output.subarray(6 + 33, 6 + 33 + 33)\n    s[0] = 0x00\n    s.set(sigS, 1)\n\n    let lenS = 33\n    let posS = 0\n    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);\n\n    s = s.subarray(posS)\n    if (s[0] & 0x80) return 1\n    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1\n\n    // Set output length for return\n    obj.outputlen = 6 + lenR + lenS\n\n    // Output in specified format\n    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n    output[0] = 0x30\n    output[1] = obj.outputlen - 2\n    output[2] = 0x02\n    output[3] = r.length\n    output.set(r, 4)\n    output[4 + lenR] = 0x02\n    output[5 + lenR] = s.length\n    output.set(s, 6 + lenR)\n\n    return 0\n  },\n\n  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js\n  // Adapted for Uint8Array instead Buffer\n  signatureImport (output, sig) {\n    if (sig.length < 8) return 1\n    if (sig.length > 72) return 1\n    if (sig[0] !== 0x30) return 1\n    if (sig[1] !== sig.length - 2) return 1\n    if (sig[2] !== 0x02) return 1\n\n    const lenR = sig[3]\n    if (lenR === 0) return 1\n    if (5 + lenR >= sig.length) return 1\n    if (sig[4 + lenR] !== 0x02) return 1\n\n    const lenS = sig[5 + lenR]\n    if (lenS === 0) return 1\n    if ((6 + lenR + lenS) !== sig.length) return 1\n\n    if (sig[4] & 0x80) return 1\n    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1\n\n    if (sig[lenR + 6] & 0x80) return 1\n    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1\n\n    let sigR = sig.subarray(4, 4 + lenR)\n    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)\n    if (sigR.length > 32) return 1\n\n    let sigS = sig.subarray(6 + lenR)\n    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)\n    if (sigS.length > 32) throw new Error('S length is too long')\n\n    let r = new BN(sigR)\n    if (r.cmp(ecparams.n) >= 0) r = new BN(0)\n\n    let s = new BN(sig.subarray(6 + lenR))\n    if (s.cmp(ecparams.n) >= 0) s = new BN(0)\n\n    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)\n    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)\n\n    return 0\n  },\n\n  ecdsaSign (obj, message, seckey, data, noncefn) {\n    if (noncefn) {\n      const _noncefn = noncefn\n      noncefn = (counter) => {\n        const nonce = _noncefn(message, seckey, null, data, counter)\n\n        const isValid = nonce instanceof Uint8Array && nonce.length === 32\n        if (!isValid) throw new Error('This is the way')\n\n        return new BN(nonce)\n      }\n    }\n\n    const d = new BN(seckey)\n    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1\n\n    let sig\n    try {\n      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })\n    } catch (err) {\n      return 1\n    }\n\n    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)\n    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)\n    obj.recid = sig.recoveryParam\n\n    return 0\n  },\n\n  ecdsaVerify (sig, msg32, pubkey) {\n    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }\n\n    const sigr = new BN(sigObj.r)\n    const sigs = new BN(sigObj.s)\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1\n    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3\n\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 2\n\n    const point = pair.getPublic()\n    const isValid = ec.verify(msg32, sigObj, point)\n    return isValid ? 0 : 3\n  },\n\n  ecdsaRecover (output, sig, recid, msg32) {\n    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }\n\n    const sigr = new BN(sigObj.r)\n    const sigs = new BN(sigObj.s)\n    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1\n\n    if (sigr.isZero() || sigs.isZero()) return 2\n\n    // Can throw `throw new Error('Unable to find sencond key candinate');`\n    let point\n    try {\n      point = ec.recoverPubKey(msg32, sigObj, recid)\n    } catch (err) {\n      return 2\n    }\n\n    savePublicKey(output, point)\n\n    return 0\n  },\n\n  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {\n    const pair = loadPublicKey(pubkey)\n    if (pair === null) return 1\n\n    const scalar = new BN(seckey)\n    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2\n\n    const point = pair.getPublic().mul(scalar)\n\n    if (hashfn === undefined) {\n      const data = point.encode(null, true)\n      const sha256 = ec.hash().update(data).digest()\n      for (let i = 0; i < 32; ++i) output[i] = sha256[i]\n    } else {\n      if (!xbuf) xbuf = new Uint8Array(32)\n      const x = point.getX().toArray('be', 32)\n      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]\n\n      if (!ybuf) ybuf = new Uint8Array(32)\n      const y = point.getY().toArray('be', 32)\n      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]\n\n      const hash = hashfn(xbuf, ybuf, data)\n\n      const isValid = hash instanceof Uint8Array && hash.length === output.length\n      if (!isValid) return 2\n\n      output.set(hash)\n    }\n\n    return 0\n  }\n}\n","const errors = {\n  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',\n  TWEAK_ADD:\n    'The tweak was out of range or the resulted private key is invalid',\n  TWEAK_MUL: 'The tweak was out of range or equal to zero',\n  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',\n  SECKEY_INVALID: 'Private Key is invalid',\n  PUBKEY_PARSE: 'Public Key could not be parsed',\n  PUBKEY_SERIALIZE: 'Public Key serialization error',\n  PUBKEY_COMBINE: 'The sum of the public keys is not valid',\n  SIG_PARSE: 'Signature could not be parsed',\n  SIGN: 'The nonce generation function failed, or the private key was invalid',\n  RECOVER: 'Public key could not be recover',\n  ECDH: 'Scalar was invalid (zero or overflow)'\n}\n\nfunction assert (cond, msg) {\n  if (!cond) throw new Error(msg)\n}\n\nfunction isUint8Array (name, value, length) {\n  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)\n\n  if (length !== undefined) {\n    if (Array.isArray(length)) {\n      const numbers = length.join(', ')\n      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`\n      assert(length.includes(value.length), msg)\n    } else {\n      const msg = `Expected ${name} to be an Uint8Array with length ${length}`\n      assert(value.length === length, msg)\n    }\n  }\n}\n\nfunction isCompressed (value) {\n  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')\n}\n\nfunction getAssertedOutput (output = (len) => new Uint8Array(len), length) {\n  if (typeof output === 'function') output = output(length)\n  isUint8Array('output', output, length)\n  return output\n}\n\nfunction toTypeString (value) {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nmodule.exports = (secp256k1) => {\n  return {\n    contextRandomize (seed) {\n      assert(\n        seed === null || seed instanceof Uint8Array,\n        'Expected seed to be an Uint8Array or null'\n      )\n      if (seed !== null) isUint8Array('seed', seed, 32)\n\n      switch (secp256k1.contextRandomize(seed)) {\n        case 1:\n          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)\n      }\n    },\n\n    privateKeyVerify (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      return secp256k1.privateKeyVerify(seckey) === 0\n    },\n\n    privateKeyNegate (seckey) {\n      isUint8Array('private key', seckey, 32)\n\n      switch (secp256k1.privateKeyNegate(seckey)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    privateKeyTweakAdd (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    privateKeyTweakMul (seckey, tweak) {\n      isUint8Array('private key', seckey, 32)\n      isUint8Array('tweak', tweak, 32)\n\n      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {\n        case 0:\n          return seckey\n        case 1:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    publicKeyVerify (pubkey) {\n      isUint8Array('public key', pubkey, [33, 65])\n\n      return secp256k1.publicKeyVerify(pubkey) === 0\n    },\n\n    publicKeyCreate (seckey, compressed = true, output) {\n      isUint8Array('private key', seckey, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCreate(output, seckey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SECKEY_INVALID)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyConvert (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyConvert(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyNegate (pubkey, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyNegate(output, pubkey)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyCombine (pubkeys, compressed = true, output) {\n      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')\n      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')\n      for (const pubkey of pubkeys) {\n        isUint8Array('public key', pubkey, [33, 65])\n      }\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyCombine(output, pubkeys)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_COMBINE)\n        case 3:\n          throw new Error(errors.PUBKEY_SERIALIZE)\n      }\n    },\n\n    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_ADD)\n      }\n    },\n\n    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('tweak', tweak, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.TWEAK_MUL)\n      }\n    },\n\n    signatureNormalize (sig) {\n      isUint8Array('signature', sig, 64)\n\n      switch (secp256k1.signatureNormalize(sig)) {\n        case 0:\n          return sig\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n      }\n    },\n\n    signatureExport (sig, output) {\n      isUint8Array('signature', sig, 64)\n      output = getAssertedOutput(output, 72)\n\n      const obj = { output, outputlen: 72 }\n      switch (secp256k1.signatureExport(obj, sig)) {\n        case 0:\n          return output.slice(0, obj.outputlen)\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    signatureImport (sig, output) {\n      isUint8Array('signature', sig)\n      output = getAssertedOutput(output, 64)\n\n      switch (secp256k1.signatureImport(output, sig)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaSign (msg32, seckey, options = {}, output) {\n      isUint8Array('message', msg32, 32)\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')\n      output = getAssertedOutput(output, 64)\n\n      const obj = { signature: output, recid: null }\n      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {\n        case 0:\n          return obj\n        case 1:\n          throw new Error(errors.SIGN)\n        case 2:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdsaVerify (sig, msg32, pubkey) {\n      isUint8Array('signature', sig, 64)\n      isUint8Array('message', msg32, 32)\n      isUint8Array('public key', pubkey, [33, 65])\n\n      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {\n        case 0:\n          return true\n        case 3:\n          return false\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.PUBKEY_PARSE)\n      }\n    },\n\n    ecdsaRecover (sig, recid, msg32, compressed = true, output) {\n      isUint8Array('signature', sig, 64)\n      assert(\n        toTypeString(recid) === 'Number' &&\n          recid >= 0 &&\n          recid <= 3,\n        'Expected recovery id to be a Number within interval [0, 3]'\n      )\n      isUint8Array('message', msg32, 32)\n      isCompressed(compressed)\n      output = getAssertedOutput(output, compressed ? 33 : 65)\n\n      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.SIG_PARSE)\n        case 2:\n          throw new Error(errors.RECOVER)\n        case 3:\n          throw new Error(errors.IMPOSSIBLE_CASE)\n      }\n    },\n\n    ecdh (pubkey, seckey, options = {}, output) {\n      isUint8Array('public key', pubkey, [33, 65])\n      isUint8Array('private key', seckey, 32)\n      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')\n      if (options.data !== undefined) isUint8Array('options.data', options.data)\n      if (options.hashfn !== undefined) {\n        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')\n        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)\n        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)\n        isUint8Array('output', output)\n      } else {\n        output = getAssertedOutput(output, 32)\n      }\n\n      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {\n        case 0:\n          return output\n        case 1:\n          throw new Error(errors.PUBKEY_PARSE)\n        case 2:\n          throw new Error(errors.ECDH)\n      }\n    }\n  }\n}\n"],"names":["_Buffer","module","exports","ALPHABET","length","TypeError","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","alloc","psz","zeroes","size","b256","carry","it3","Error","it4","vch","allocUnsafe","fill","encode","Array","isArray","from","isBuffer","pbegin","pend","b58","it1","it2","str","repeat","decode","string","buffer","basex","base58","Buffer","checksumFn","decodeRaw","payload","slice","checksum","newChecksum","concat","createHash","bs58checkBase","tmp","update","digest","assert","crypto","bs58check","RIPEMD160","secp256k1","MASTER_SECRET","HARDENED_OFFSET","BITCOIN_VERSIONS","private","public","HDKey","versions","this","depth","index","_privateKey","_publicKey","chainCode","_fingerprint","parentFingerprint","setPublicKey","hdkey","publicKey","_identifier","hash160","readUInt32BE","serialize","version","key","writeUInt32BE","writeUInt8","fingerprint","copy","buf","sha","Object","defineProperty","prototype","get","identifier","set","value","equal","privateKeyVerify","publicKeyCreate","publicKeyVerify","publicKeyConvert","privateKey","derive","path","entries","split","forEach","c","hardened","childIndex","parseInt","deriveChild","test","data","isHardened","indexBuffer","pk","zb","I","createHmac","IL","IR","hd","privateKeyTweakAdd","err","publicKeyTweakAdd","sign","hash","ecdsaSign","signature","verify","ecdsaVerify","wipePrivateData","randomBytes","toJSON","xpriv","privateExtendedKey","xpub","publicExtendedKey","fromMasterSeed","seedBuffer","fromExtendedKey","base58key","skipVerification","keyBuffer","readUInt8","fromJSON","obj","ec","EC","ecparams","curve","BN","n","constructor","loadPublicKey","pubkey","first","xbuf","cmp","p","toRed","red","y","redSqr","redIMul","redIAdd","b","redSqrt","isOdd","redNeg","keyPair","pub","loadCompressedPublicKey","subarray","ybuf","x3","redISub","isZero","loadUncompressedPublicKey","savePublicKey","output","point","contextRandomize","seckey","bn","privateKeyNegate","negate","sub","umod","toArrayLike","tweak","iadd","isub","tweaked","privateKeyTweakMul","imul","keyFromPrivate","getPublic","pair","publicKeyNegate","publicKeyCombine","pubkeys","pairs","add","isInfinity","g","mul","publicKeyTweakMul","signatureNormalize","sig","r","s","nh","signatureExport","sigR","sigS","lenR","posR","lenS","posS","outputlen","signatureImport","message","noncefn","_noncefn","counter","nonce","d","canonical","k","pers","recid","recoveryParam","msg32","sigObj","sigr","sigs","ecdsaRecover","recoverPubKey","ecdh","hashfn","scalar","undefined","sha256","getX","toArray","getY","errors","cond","msg","isUint8Array","name","join","includes","isCompressed","toTypeString","getAssertedOutput","len","toString","call","seed","compressed","options"],"sourceRoot":""}